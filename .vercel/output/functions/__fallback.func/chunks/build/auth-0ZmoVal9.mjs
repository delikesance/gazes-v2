import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { createClient } from '@supabase/supabase-js';
import { h as He, e as je } from './server.mjs';
import 'vue';
import '../nitro/nitro.mjs';
import 'cheerio';
import 'node:http';
import 'node:https';
import 'node:events';
import 'node:buffer';
import 'node:fs';
import 'node:path';
import 'node:crypto';
import '@iconify/utils';
import 'consola';
import 'node:url';
import 'ipx';
import 'vue-router';
import '@iconify/vue';
import 'vue/server-renderer';

class a{static instance;supabase;constructor(){console.log("📁 [DATABASE] Initializing Supabase connection...");try{const e=je(),s=e.supabaseUrl,o=e.supabaseKey;if(!s||!o){const e="Missing required Supabase environment variables";throw console.error("❌ [DATABASE] "+e),new Error(e)}this.supabase=createClient(s,o),this.initDatabase();}catch(e){throw console.error("❌ [DATABASE] Failed to initialize:",e),e}}static getInstance(){return a.instance||(a.instance=new a),a.instance}getSupabaseClient(){return this.supabase}async initDatabase(){console.log("📁 [DATABASE] Database schema initialization completed");}async createUser(e,s,r){console.log("📁 [DATABASE] Creating user:",s,"with email:",e);const t=crypto.randomUUID(),o=new Date;try{const{data:a,error:n}=await this.supabase.from("users").insert({id:t,email:e,username:s,password:r,created_at:o.toISOString(),updated_at:o.toISOString()}).select().single();if(n){if(console.error("📁 [DATABASE] Error creating user:",n),"23505"===n.code)throw new Error("User with this email already exists");throw n}return console.log("📁 [DATABASE] User created successfully with ID:",t),{id:a.id,email:a.email,username:a.username,createdAt:new Date(a.created_at),updatedAt:new Date(a.updated_at)}}catch(a){throw console.error("📁 [DATABASE] Error creating user:",a),a}}async findUserByEmail(e){console.log("📁 [DATABASE] Looking for user by email:",e);const{data:s,error:r}=await this.supabase.from("users").select("id, email, username, password, created_at, updated_at").eq("email",e).single();if(r){if("PGRST116"===r.code)return console.log("📁 [DATABASE] User not found:",e),null;throw console.error("📁 [DATABASE] Error finding user:",r),r}return console.log("📁 [DATABASE] User found:",s.username),{...s,createdAt:new Date(s.created_at),updatedAt:new Date(s.updated_at)}}async findUserById(e){console.log("📁 [DATABASE] Looking for user by ID:",e);const{data:s,error:r}=await this.supabase.from("users").select("id, email, username, created_at, updated_at").eq("id",e).single();if(r){if("PGRST116"===r.code)return console.log("📁 [DATABASE] User not found:",e),null;throw console.error("📁 [DATABASE] Error finding user:",r),r}return console.log("📁 [DATABASE] User found:",s.username),{id:s.id,email:s.email,username:s.username,createdAt:new Date(s.created_at),updatedAt:new Date(s.updated_at)}}async findUserByUsername(e){console.log("📁 [DATABASE] Looking for user by username:",e);const{data:s,error:r}=await this.supabase.from("users").select("id, email, username, password, created_at, updated_at").eq("username",e).single();if(r){if("PGRST116"===r.code)return console.log("📁 [DATABASE] User not found:",e),null;throw console.error("📁 [DATABASE] Error finding user:",r),r}return console.log("📁 [DATABASE] User found:",s.username),{...s,createdAt:new Date(s.created_at),updatedAt:new Date(s.updated_at)}}async updateUser(e,s){console.log("📁 [DATABASE] Updating user:",e);const r={updated_at:(new Date).toISOString()};void 0!==s.email&&(r.email=s.email),void 0!==s.username&&(r.username=s.username),void 0!==s.password&&(r.password=s.password);const{data:t,error:o}=await this.supabase.from("users").update(r).eq("id",e).select("id, email, username, created_at, updated_at").single();if(o)throw console.error("📁 [DATABASE] Error updating user:",o),o;return console.log("📁 [DATABASE] User updated successfully"),{id:t.id,email:t.email,username:t.username,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at)}}async deleteUser(e){console.log("📁 [DATABASE] Deleting user:",e);const{error:s}=await this.supabase.from("users").delete().eq("id",e);return s?(console.error("📁 [DATABASE] Error deleting user:",s),false):(console.log("📁 [DATABASE] User deleted successfully"),true)}async getAllUsers(){console.log("📁 [DATABASE] Getting all users");const{data:e,error:s}=await this.supabase.from("users").select("id, email, username, created_at, updated_at").order("created_at",{ascending:false});if(s)throw console.error("📁 [DATABASE] Error getting all users:",s),s;const r=e.map(e=>({id:e.id,email:e.email,username:e.username,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at)}));return console.log("📁 [DATABASE] Found",r.length,"users"),r}async getUserCount(){console.log("📁 [DATABASE] Getting user count");const{count:e,error:s}=await this.supabase.from("users").select("*",{count:"exact",head:true});if(s)throw console.error("📁 [DATABASE] Error getting user count:",{message:s.message,code:s.code,details:s.details,hint:s.hint}),s;return console.log("📁 [DATABASE] User count:",e),e||0}async saveWatchingProgress(e,s,r,t,o,a){console.log("📁 [DATABASE] Saving watching progress:",{userId:e,animeId:s,season:r,episode:t,currentTime:o,duration:a});const n=a>0&&o>=.9*a,i=new Date,c=crypto.randomUUID(),{data:d,error:l}=await this.supabase.from("watching_progress").upsert({id:c,user_id:e,anime_id:s,season:r,episode:t,current_time:o,duration:a,last_watched_at:i.toISOString(),completed:n},{onConflict:"user_id,anime_id,season,episode"}).select().single();if(l)throw console.error("📁 [DATABASE] Error saving watching progress:",l),l;return console.log("📁 [DATABASE] Watching progress saved successfully"),{id:d.id,userId:d.user_id,animeId:d.anime_id,season:d.season,episode:d.episode,currentTime:d.current_time,duration:d.duration,lastWatchedAt:new Date(d.last_watched_at),completed:d.completed}}async getWatchingProgress(e,s,r,t){console.log("📁 [DATABASE] Getting watching progress:",{userId:e,animeId:s,season:r,episode:t});const{data:o,error:a}=await this.supabase.from("watching_progress").select("id, user_id, anime_id, season, episode, current_time, duration, last_watched_at, completed").eq("user_id",e).eq("anime_id",s).eq("season",r).eq("episode",t).single();if(a){if("PGRST116"===a.code)return console.log("📁 [DATABASE] No watching progress found"),null;throw console.error("📁 [DATABASE] Error getting watching progress:",a),a}return console.log("📁 [DATABASE] Found watching progress:",o.current_time,"/",o.duration),{id:o.id,userId:o.user_id,animeId:o.anime_id,season:o.season,episode:o.episode,currentTime:o.current_time,duration:o.duration,lastWatchedAt:new Date(o.last_watched_at),completed:o.completed}}async getUserContinueWatching(e,s=20){console.log("📁 [DATABASE] Getting continue watching for user:",e);const{data:r,error:t}=await this.supabase.from("watching_progress").select("id, user_id, anime_id, season, episode, current_time, duration, last_watched_at, completed").eq("user_id",e).eq("completed",false).order("last_watched_at",{ascending:false}).limit(s);if(t)throw console.error("📁 [DATABASE] Error getting continue watching:",t),t;const o=r.map(e=>({id:String(e.id),userId:String(e.user_id),animeId:String(e.anime_id),season:String(e.season),episode:Number(e.episode),currentTime:Number(e.current_time),duration:Number(e.duration),lastWatchedAt:new Date(e.last_watched_at),completed:Boolean(e.completed)}));return console.log("📁 [DATABASE] Found",o.length,"continue watching items"),o}async deleteWatchingProgress(e,s,r,t){console.log("📁 [DATABASE] Deleting watching progress:",{userId:e,animeId:s,season:r,episode:t});const{error:o}=await this.supabase.from("watching_progress").delete().eq("user_id",e).eq("anime_id",s).eq("season",r).eq("episode",t);return o?(console.error("📁 [DATABASE] Error deleting watching progress:",o),false):(console.log("📁 [DATABASE] Watching progress deleted successfully"),true)}async markAsCompleted(e,s,r,t){console.log("📁 [DATABASE] Marking episode as completed:",{userId:e,animeId:s,season:r,episode:t});const{error:o}=await this.supabase.from("watching_progress").update({completed:true,last_watched_at:(new Date).toISOString()}).eq("user_id",e).eq("anime_id",s).eq("season",r).eq("episode",t);return o?(console.error("📁 [DATABASE] Error marking episode as completed:",o),false):(console.log("📁 [DATABASE] Episode marked as completed successfully"),true)}async executeSql(e){console.log("📁 [DATABASE] Executing SQL:",e.substring(0,100)+"...");const{error:s}=await this.supabase.rpc("exec_sql",{sql:e});if(s)throw s}}class n{static SALT_ROUNDS=12;static async hashPassword(e){return bcrypt.hash(e,this.SALT_ROUNDS)}static async verifyPassword(e,r){return bcrypt.compare(e,r)}static generateTokens(s){const r=je(),o=r.jwtSecret||"default-secret",a=r.jwtRefreshSecret||"default-refresh-secret",n=r.jwtExpiresIn||"7d",i=r.jwtRefreshExpiresIn||"30d",c={userId:s.id,email:s.email,username:s.username,type:"access"},d={userId:s.id,email:s.email,username:s.username,type:"refresh"};return {accessToken:jwt.sign(c,o,{expiresIn:n,issuer:"gazes-app"}),refreshToken:jwt.sign(d,a,{expiresIn:i,issuer:"gazes-app"})}}static verifyToken(s,r="access"){const a=je(),n="access"===r?a.jwtSecret:a.jwtRefreshSecret;try{return jwt.verify(s,n,{issuer:"gazes-app"})}catch(i){throw He({statusCode:401,statusMessage:"Invalid token"})}}static async createUser(e,s,r){console.log("🔐 [AUTH_SERVICE] Creating user:",s,"with email:",e),console.log("🔐 [AUTH_SERVICE] Hashing password...");const t=await this.hashPassword(r);console.log("🔐 [AUTH_SERVICE] Password hashed successfully");const o=a.getInstance(),n=await o.createUser(e,s,t);return console.log("🔐 [AUTH_SERVICE] User created successfully, returning without password"),n}static async findUserByEmail(e){console.log("🔐 [AUTH_SERVICE] Looking for user by email:",e);const s=a.getInstance(),r=await s.findUserByEmail(e);return console.log("🔐 [AUTH_SERVICE] User found:",r?"YES":"NO"),r}static async findUserById(e){console.log("🔐 [AUTH_SERVICE] Looking for user by ID:",e);const s=a.getInstance(),r=await s.findUserById(e);return console.log("🔐 [AUTH_SERVICE] User found:",r?"YES":"NO"),r}static async authenticateUser(e,s){console.log("🔐 [AUTH_SERVICE] Attempting to authenticate user:",e);const r=await this.findUserByEmail(e);if(!r)return console.log("❌ [AUTH_SERVICE] User not found:",e),null;console.log("🔐 [AUTH_SERVICE] User found, verifying password...");const t=await this.verifyPassword(s,r.password);if(console.log("🔐 [AUTH_SERVICE] Password verification result:",t?"VALID":"INVALID"),!t)return console.log("❌ [AUTH_SERVICE] Invalid password for user:",e),null;const{password:o,...a}=r;return console.log("✅ [AUTH_SERVICE] Authentication successful for user:",r.username),a}static async getUserFromRequest(e){console.log("🔐 [AUTH_SERVICE] Getting user from request...");try{const s=getCookie(e,"accessToken");if(console.log("🔐 [AUTH_SERVICE] Access token found:",!!s),!s)return console.log("❌ [AUTH_SERVICE] No access token in request"),null;console.log("🔐 [AUTH_SERVICE] Verifying access token...");const r=this.verifyToken(s,"access");console.log("🔐 [AUTH_SERVICE] Token verified for user ID:",r.userId),console.log("🔐 [AUTH_SERVICE] Finding user by ID...");const t=await this.findUserById(r.userId);return console.log("🔐 [AUTH_SERVICE] User found from token:",t?"YES":"NO"),t}catch(s){return console.error("❌ [AUTH_SERVICE] Error getting user from request:",s),null}}static setAuthCookies(e,s){setCookie(e,"accessToken",s.accessToken,{httpOnly:true,secure:"production"==="production",sameSite:"lax",maxAge:604800,path:"/"}),setCookie(e,"refreshToken",s.refreshToken,{httpOnly:true,secure:"production"==="production",sameSite:"lax",maxAge:2592e3,path:"/"});}static clearAuthCookies(e){deleteCookie(e,"accessToken"),deleteCookie(e,"refreshToken");}}const i=defineEventHandler(async e=>{if(e.node.req.url?.startsWith("/api/auth"))return;if(["/api/search","/api/catalogue","/api/anime","/api/providers","/api/proxy"].some(s=>e.node.req.url?.startsWith(s)))return;const s=await n.getUserFromRequest(e);if(!s)throw He({statusCode:401,statusMessage:"Authentication required"});e.context.user=s;});

export { i as default };
//# sourceMappingURL=auth-0ZmoVal9.mjs.map

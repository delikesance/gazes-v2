import { computed, toValue, ref, shallowRef, toRef, nextTick, unref, getCurrentInstance, onServerPrefetch } from 'vue';
import { debounce } from 'perfect-debounce';
import { d as ke, j as he, h as He } from './server.mjs';

function f(...f){const m="string"==typeof f[f.length-1]?f.pop():void 0;(function(e,a){if("string"==typeof e)return  false;if("object"==typeof e&&null!==e)return  false;if("function"==typeof e&&"function"==typeof a)return  false;return  true})(f[0],f[1])&&f.unshift(m);let[h,g,P={}]=f;const x=computed(()=>toValue(h));if("string"!=typeof x.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof g)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const C=ke();P.server??=true,P.default??=p,P.getCachedData??=D,P.lazy??=false,P.immediate??=true,P.deep??=he.deep,P.dedupe??="cancel",P._functionName,C._asyncData[x.value];const k={cause:"initial",dedupe:P.dedupe};C._asyncData[x.value]?._init||(k.cachedData=P.getCachedData(x.value,C,{cause:"initial"}),C._asyncData[x.value]=function(a,t,s,d,l){a.payload._errors[t]??=void 0;const f=d.getCachedData!==D,v=s,p=d.deep?ref:shallowRef,m=void 0!==l,h=a.hook("app:data:refresh",async e=>{e&&!e.includes(t)||await g.execute({cause:"refresh:hook"});}),g={data:p(m?l:d.default()),pending:computed(()=>"pending"===g.status.value),error:toRef(a.payload._errors,t),status:shallowRef("idle"),execute:(...e)=>{const[s,r]=e,n=s&&void 0===r&&"object"==typeof s?s:{};if(a._asyncDataPromises[t]){if("defer"===(n.dedupe??d.dedupe))return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=true;}{const e="cachedData"in n?n.cachedData:d.getCachedData(t,a,{cause:n.cause??"refresh:manual"});if(void 0!==e)return a.payload.data[t]=g.data.value=e,g.error.value=void 0,g.status.value="success",Promise.resolve(e)}g.status.value="pending";const o=new Promise((e,t)=>{try{e(v(a));}catch(s){t(s);}}).then(async e=>{if(o.cancelled)return a._asyncDataPromises[t];let s=e;d.transform&&(s=await d.transform(e)),d.pick&&(s=function(e,a){const t={};for(const s of a)t[s]=e[s];return t}(s,d.pick)),a.payload.data[t]=s,g.data.value=s,g.error.value=void 0,g.status.value="success";}).catch(e=>{if(o.cancelled)return a._asyncDataPromises[t];g.error.value=He(e),g.data.value=unref(d.default()),g.status.value="error";}).finally(()=>{o.cancelled||delete a._asyncDataPromises[t];});return a._asyncDataPromises[t]=o,a._asyncDataPromises[t]},_execute:debounce((...e)=>g.execute(...e),0,{leading:true}),_default:d.default,_deps:0,_init:true,_hash:void 0,_off:()=>{h(),a._asyncData[t]?._init&&(a._asyncData[t]._init=false),f||nextTick(()=>{a._asyncData[t]?._init||(_(a,t),g.execute=()=>Promise.resolve());});}};return g}(C,x.value,g,P,k.cachedData));C._asyncData[x.value]._deps++;if(false!==P.server&&C.payload.serverRendered&&P.immediate){const e=C._asyncData[x.value].execute(k);getCurrentInstance()?onServerPrefetch(()=>e):C.hook("app:created",async()=>{await e;});}const w={data:v(()=>C._asyncData[x.value]?.data),pending:v(()=>C._asyncData[x.value]?.pending),status:v(()=>C._asyncData[x.value]?.status),error:v(()=>C._asyncData[x.value]?.error),refresh:(...e)=>C._asyncData[x.value].execute(...e),execute:(...e)=>C._asyncData[x.value].execute(...e),clear:()=>_(C,x.value)},b=Promise.resolve(C._asyncDataPromises[x.value]).then(()=>w);return Object.assign(b,w),b}function v(a){return computed({get:()=>a()?.value,set(e){const t=a();t&&(t.value=e);}})}function _(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=void 0),e._asyncData[a]&&(e._asyncData[a].data.value=unref(e._asyncData[a]._default()),e._asyncData[a].error.value=void 0,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=true),e._asyncDataPromises[a]=void 0);}const p=()=>{},D=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;

export { f };
//# sourceMappingURL=asyncData-BOLdWyFS.mjs.map
